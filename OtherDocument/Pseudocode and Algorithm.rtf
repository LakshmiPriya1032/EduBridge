{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset1 Cambria Math;}{\f2\fnil\fcharset0 Cambria Math;}}
{\*\generator Riched20 10.0.22621}{\*\mmathPr\mmathFont1\mwrapIndent1440 }\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 Exercise-1 Module-7\par
Write a Pseudocode for these problems\par
1. S = (A + B + C) / Y\par
Step 1 Start\par
Step 2 Read values for X, Y and Z as input\par
Step 3 calculate W = X + Y + Z\par
Step 4 calculate S = W / 3\par
Step 5 Write the value of S\par
Step 6 Stop\par
2. Convert from Celsius to Fahrenheit (Multiply by 9, then divide by 5, then add 32 ) F = (9/5)C + 32\par
step 1 Start\par
Step 2 Read the value of c as input\par
step 3 Calculate X = 9 * c \par
step 4 Calculate Y = X / 5\par
step 5 Calculate F = Y + 32\par
Step 6 Write the values of F\par
Step 7 Stop\par
\par
3. Area of Circle (\f1\u-10187?\u-9164?\f0  = \f1\u-10187?\u-8437?\u-10187?\u-9121?\f0 2)\par
Step 1 Start\par
step 2 Get the value of radius r as input\par
step 3 Calculate R= (r * r)\par
step 4 Calculate A = 3.14 * R\par
step 5 Write the value of A\par
step 6 Stop\par
4. Volume of Sphere ( 4/3\f1\u-10187?\u-8437?\u-10187?\u-9121?\f0 3)\par
step 1 Start\par
step 2 Get the value of r as input\par
step 3 Calculate R=(r * r * r)\par
step 4 Calculate A = 3*3.14* R\par
step 5 Calculate S= 4 / A\par
step 6 Write the value of S\par
step 7 Stop\par
5. Average speed = \f1\u-10187?\u-9161?\u-10187?\u-9130?\u-10187?\u-9120?\u-10187?\u-9119?\u-10187?\u-9138?\u-10187?\u-9125?\u-10187?\u-9136?\u-10187?\u-9134?\f0  \f1\u-10187?\u-9145?\u-10187?\u-9121?\u-10187?\u-9138?\u-10187?\u-9117?\u-10187?\u-9134?\u-10187?\u-9127?\u-10187?\u-9134?\f0  s=d/t\par
step 1 Start\par
step 2 Get the value of d and t as input\par
Step 3 calculate S = d/t\par
step 4 Write the value of S\par
step 5 Stop\par
\b 7\f2 .\f0 ALGORITHM\b0\par
Exercise\f2 -\f0 2\par
Case\f2  \f0 1\par
\f2    \f0 *If\f2  \f0 we\f2  \f0 are\f2  \f0 taking\f2  \f0 the\f2  \f0 first\f2  \f0 condition\f2 , \f0 the\f2  \f0 person\f2  \f0 will\f2  \f0 call\f2  \f0 his\f2  \f0 friend\f2  \f0 before\f2  \f0 he\f2  \f0 reaches\f2  \f0 the\f2  \f0 bus\f2  \f0 stop\f2  \f0 and\f2  \f0 his\f2  \f0 friend\f2  \f0 will\f2  \f0 wait\f2  \f0 before\f2  \f0 he\f2  \f0 reaches\f2  \f0 the\f2  \f0 bus\f2  \f0 stop\f2 . \f0 Also\f2 , \f0 he\f2  \f0 doesn't\f2  \f0 want\f2  \f0 to\f2  \f0 spend\f2  \f0 time\f2  \f0 traveling\f2 . \f0 So\f2 , \f0 it\f2  \f0 is\f2  \f0 a\f2  \f0 best\f2  \f0 condition\f2 .\f0\par
Case\f2  \f0 2\f2  \f0\par
\f2   \f0 *If\f2  \f0 we\f2  \f0 take\f2  \f0 the\f2  \f0 second\f2  \f0 condition\f2 , \f0 the\f2  \f0 person\f2  \f0 will\f2  \f0 take\f2  \f0 the\f2  \f0 auto\f2  \f0 and\f2  \f0 reach\f2  \f0 the\f2  \f0 destination\f2  \f0 on\f2  \f0 time\f2  \f0 but\f2  \f0 the\f2  \f0 cost\f2  \f0 will\f2  \f0 be\f2  \f0 little\f2  \f0 high\f2 . \f0 So\f2 , \f0 it\f2  \f0 is\f2  \f0 average\f2  \f0 condition\f2 .\f0\par
Case\f2  \f0 3\par
\f2   \f0 *\f2  \f0 If\f2  \f0 we\f2  \f0 take\f2  \f0 the\f2  \f0 third\f2  \f0 condition\f2 , \f0 the\f2  \f0 person\f2  \f0 has\f2  \f0 to\f2  \f0 take\f2  \f0 a\f2  \f0 new\f2  \f0 bus\f2 . \f0 Even\f2  \f0 after\f2  \f0 he\f2  \f0 reaches\f2  \f0 the\f2  \f0 bus\f2  \f0 stop\f2  \f0 he\f2  \f0 also\f2  \f0 has\f2  \f0 to\f2  \f0 wait\f2  \f0 for\f2  \f0 another\f2  \f0 bus\f2  \f0 so\f2  \f0 it\f2  \f0 will\f2  \f0 take\f2  \f0 some\f2  \f0 time\f2  \f0 but\f2   \f0 he\f2  \f0 has\f2  \f0 to\f2  \f0 spend\f2  \f0 less\f2  \f0 money\f2  \f0 only\f2 . \f0 So\f2 , \f0 it\f2  \f0 is\f2  \f0 the\f2  \f0 worst\f2  \f0 condition\f2 .\f0\par
\lang9 EXERCISE-3 MODULE-7\par
1.Quick Sort Algorithm\par
Quick sort is one of the most famous sorting algorithms based on divide and conquers strategy which results in an O(n log n) complexity. \par
So, the algorithm starts by picking a single item which is called pivot and moving all smaller items before it, while all greater elements in the later portion of the list. \par
This is the main quicksort operation named as a partition, recursively repeated on lesser and greater sublists until their size is one or zero - in which case the list is wholly sorted. \par
Choosing an appropriate pivot, as an example, the central element is essential for avoiding the severely reduced performance of O(n2).\par
Choosing the pivot\par
Picking a good pivot is necessary for the fast implementation of quicksort. However, it is typical to determine a good pivot. Some of the ways of choosing a pivot are as follows -\par
Pivot can be random, i.e. select the random pivot from the given array.\par
Pivot can either be the rightmost element of the leftmost element of the given array.\par
Select median as the pivot element.\par
Algorithm For Quick_Sort(list)\par
Pre: list 6= fi\par
Post: the list has been sorted in ascending order\par
if list.Count = 1 // list already sorted\par
return list\par
end if\par
pivot <- Median_Value(list)\par
for i <- 0 to list.Count - 1\par
if list[i] = pivot\par
equal.Insert(list[i])\par
end if\par
if list[i] < pivot\par
less.Insert(list[i])\par
end if\par
if list[i] > pivot\par
greater.Insert(list[i])\par
end if\par
end for\par
return Concatenate(Quick_Sort(less), equal, Quick_Sort(greater))\par
end Quick_sort\par
\par
Working of Quick Sort Algorithm\par
Pick an element, called a pivot or refer it as the partitioning element, from the array. For instance, let us consider the last element as a pivot.\par
Partition: rearrange the array such that all elements with values less than the pivot come before the pivot (i.e., on the left of the pivot), while all elements with values greater than the pivot come after it (i.e., on the right of pivot). The pivot element will be in its final position after it.\par
Recursively apply the above steps to the sub-array of elements on the left side of the pivot and on the right side of the pivot to get a sorted array.\par
Now, using pictorial representation, let\rquote s try to sort an array which has initial values as X= \{75, 26, 15, 67, 54, 31, 49\}.\par
\par
In the above representation, we select the element at the last index of the array as a pivot, which is 49 and then call partition() to thereby re-arrange the elements of the array in a way that elements less than 49 are before it in and elements greater than 49 are after it.\par
Then, after the first pass, we consider the subarrays at left and right and select a partition element for them. Here, in the above representation, we select 31 as a pivot from the left array and 67 as a pivot from the right array. And once again call the partition() to split the array.\par
Thus, we recursively keep partitioning the array with help of pivot unless we obtain a sorted array.\par
2.Selection Sort Algorithm\par
Selection Sort algorithm is used to arrange a list of elements in a particular order (Ascending or Descending).\par
 In selection sort, the first element in the list is selected and it is compared repeatedly with all the remaining elements in the list. \par
If any element is smaller than the selected element (for Ascending order), then both are swapped so that first position is filled with the smallest element in the sorted order. \par
Next, we select the element at a second position in the list and it is compared with all the remaining elements in the list. \par
If any element is smaller than the selected element, then both are swapped. This procedure is repeated until the entire list is sorted.\par
Step by Step Process\par
The selection sort algorithm is performed using the following steps...\par
Step 1 - Select the first element of the list (i.e., Element at first position in the list).\par
Step 2: Compare the selected element with all the other elements in the list.\par
Step 3: In every comparision, if any element is found smaller than the selected element (for Ascending order), then both are swapped.\par
Step 4: Repeat the same procedure with element in the next position in the list till the entire list is sorted.\par
FOR EXAMPLE\par
Lets consider the following array as an example: arr[] = \{64, 25, 12, 22, 11\}\par
First pass:\par
For the first position in the sorted array, the whole array is traversed from index 0 to 4 sequentially. The first position where 64 is stored presently, after traversing whole array it is clear that 11 is the lowest value.\par
   64   \tab    25   \tab    12   \tab    22   \tab    11   \par
Thus, replace 64 with 11. After one iteration 11, which happens to be the least value in the array, tends to appear in the first position of the sorted list.\par
   11   \tab    25   \tab    12   \tab    22   \tab    64   \par
Second Pass:\par
For the second position, where 25 is present, again traverse the rest of the array in a sequential manner.\par
   11   \tab    25   \tab    12   \tab    22   \tab    64   \par
After traversing, we found that 12 is the second lowest value in the array and it should appear at the second place in the array, thus swap these values.\par
   11   \tab    12   \tab    25   \tab    22   \tab    64   \par
Third Pass:\par
Now, for third place, where 25 is present again traverse the rest of the array and find the third least value present in the array.\par
   11   \tab    12   \tab    25   \tab    22   \tab    64   \par
While traversing, 22 came out to be the third least value and it should appear at the third place in the array, thus swap 22 with element present at third position.\par
   11   \tab    12   \tab    22   \tab    25   \tab    64   \par
Fourth pass:\par
Similarly, for fourth position traverse the rest of the array and find the fourth least element in the array \par
As 25 is the 4th lowest value hence, it will place at the fourth position.\par
   11   \tab    12   \tab    22   \tab    25   \tab    64   \par
Fifth Pass:\par
At last the largest value present in the array automatically get placed at the last position in the array\par
The resulted array is the sorted array.\par
   11   \tab    12   \tab    22   \tab    25   \tab    64   \par
Exercise-4\par
1.LINEAR SEARCH ALGORITHM\par
\par
Linear search, often known as sequential search, is the most basic search technique.\par
Take the entire list and search for the particular element from the list by checking each element from the beginning\par
In linear search the element index is noted as a result.\par
If the element is not found, then it returns a NULL value.\par
Here is an example for a linear search algorithm.\par
\par
The procedures for implementing linear search are as follows:\par
Step 1: First, read the search element (Target element) in the array.\par
Step 2: In the second step compare the search element with the first element in the array.\par
Step 3: If both are matched, display "Target element is found" and terminate the Linear Search function. \par
Step 4: If both are not matched, compare the search element with the next element in the array. \par
Step 5: In this step, repeat steps 3 and 4 until the search (Target) element is compared with the last element of the array.\par
Step 6 - If the last element in the list does not match, the Linear Search Function will be terminated, and the message "Element is not found" will be displayed.\par
\par
\par
\par
FOR EXAMPLE:\par
The given list consists of 7 elements that are 6 arrays. Now, find out 39 from the list of indexes\par
\par
Algorithm:\par
Step 1:  First, read the search element 39 in the array.\par
Step 2: Now, compare each element in the array and find 39.\par
Step3:  if we take the first element a[0] it is 13 . So, Element is not found.\par
Step4: Now move to the next element a[1] is 9. Element is not found.\par
Step5: Like this move to the next next element a[2]  is 21, a[3] is 15.\par
Step6: Now the next element a[4] is 39 it is matching the target. So, the target element is found.\par
\par
\par
2.Binary Search Algorithm\par
 Binary search is the most frequently used technique as it is much faster than a linear search.\par
In the binary search method, the collection is repeatedly divided into half and the key element is searched in the left or right half of the collection depending on whether the key is less than or greater than the mid element of the collection.\par
A simple Binary Search Algorithm is as follows:\par
Calculate the mid element of the collection.\par
Compare the key items with the mid element.\par
If key = middle element, then we return the mid index position for the key found.\par
Else If key > mid element, then the key lies in the right half of the collection. Thus repeat steps 1 to 3 on the lower (right) half of the collection.\par
Else key < mid element, then the key is in the upper half of the collection. Hence you need to repeat the binary search in the upper half.\par
For example, take the following sorted array of 10 elements\par
\par
Let\rquote s calculate the middle location of the array.\par
Mid = 0+9/2 = 4\par
\par
#1) Key = 21\par
First, we will compare the key value with the [mid] element and we find that the element value at mid = 21.\par
\par
Thus we find that key = [mid]. Hence the key is found at position 4 in the array.\par
#2) Key = 25\par
\par
We first compare the key value to mid. As (21 < 25), we will directly search for the key in the upper half of the array.\par
\par
Now again we will find the mid for the upper half of the array.\par
Mid = 4+9/2 = 6\par
The value at location [mid] = 25\par
\par
Now we compare the key element with the mid element. So (25 == 25), hence we have found the key at location [mid] = 6.\par
Thus we repeatedly divide the array and by comparing the key element with the mid, we decide in which half to search for the key. Exercise-4\par
1.LINEAR SEARCH ALGORITHM\par
\par
Linear search, often known as sequential search, is the most basic search technique.\par
Take the entire list and search for the particular element from the list by checking each element from the beginning\par
In linear search the element index is noted as a result.\par
If the element is not found, then it returns a NULL value.\par
Here is an example for a linear search algorithm.\par
\par
The procedures for implementing linear search are as follows:\par
Step 1: First, read the search element (Target element) in the array.\par
Step 2: In the second step compare the search element with the first element in the array.\par
Step 3: If both are matched, display "Target element is found" and terminate the Linear Search function. \par
Step 4: If both are not matched, compare the search element with the next element in the array. \par
Step 5: In this step, repeat steps 3 and 4 until the search (Target) element is compared with the last element of the array.\par
Step 6 - If the last element in the list does not match, the Linear Search Function will be terminated, and the message "Element is not found" will be displayed.\par
\par
\par
\par
FOR EXAMPLE:\par
The given list consists of 7 elements that are 6 arrays. Now, find out 39 from the list of indexes\par
\par
Algorithm:\par
Step 1:  First, read the search element 39 in the array.\par
Step 2: Now, compare each element in the array and find 39.\par
Step3:  if we take the first element a[0] it is 13 . So, Element is not found.\par
Step4: Now move to the next element a[1] is 9. Element is not found.\par
Step5: Like this move to the next next element a[2]  is 21, a[3] is 15.\par
Step6: Now the next element a[4] is 39 it is matching the target. So, the target element is found.\par
\par
\par
2.Binary Search Algorithm\par
 Binary search is the most frequently used technique as it is much faster than a linear search.\par
In the binary search method, the collection is repeatedly divided into half and the key element is searched in the left or right half of the collection depending on whether the key is less than or greater than the mid element of the collection.\par
A simple Binary Search Algorithm is as follows:\par
Calculate the mid element of the collection.\par
Compare the key items with the mid element.\par
If key = middle element, then we return the mid index position for the key found.\par
Else If key > mid element, then the key lies in the right half of the collection. Thus repeat steps 1 to 3 on the lower (right) half of the collection.\par
Else key < mid element, then the key is in the upper half of the collection. Hence you need to repeat the binary search in the upper half.\par
For example, take the following sorted array of 10 elements\par
\par
Let\rquote s calculate the middle location of the array.\par
Mid = 0+9/2 = 4\par
\par
#1) Key = 21\par
First, we will compare the key value with the [mid] element and we find that the element value at mid = 21.\par
\par
Thus we find that key = [mid]. Hence the key is found at position 4 in the array.\par
#2) Key = 25\par
\par
We first compare the key value to mid. As (21 < 25), we will directly search for the key in the upper half of the array.\par
\par
Now again we will find the mid for the upper half of the array.\par
Mid = 4+9/2 = 6\par
The value at location [mid] = 25\par
\par
Now we compare the key element with the mid element. So (25 == 25), hence we have found the key at location [mid] = 6.\par
Thus we repeatedly divide the array and by comparing the key element with the mid, we decide in which half to search for the key. Exercise-4\par
1.LINEAR SEARCH ALGORITHM\par
\par
Linear search, often known as sequential search, is the most basic search technique.\par
Take the entire list and search for the particular element from the list by checking each element from the beginning\par
In linear search the element index is noted as a result.\par
If the element is not found, then it returns a NULL value.\par
Here is an example for a linear search algorithm.\par
\par
The procedures for implementing linear search are as follows:\par
Step 1: First, read the search element (Target element) in the array.\par
Step 2: In the second step compare the search element with the first element in the array.\par
Step 3: If both are matched, display "Target element is found" and terminate the Linear Search function. \par
Step 4: If both are not matched, compare the search element with the next element in the array. \par
Step 5: In this step, repeat steps 3 and 4 until the search (Target) element is compared with the last element of the array.\par
Step 6 - If the last element in the list does not match, the Linear Search Function will be terminated, and the message "Element is not found" will be displayed.\par
\par
\par
\par
FOR EXAMPLE:\par
The given list consists of 7 elements that are 6 arrays. Now, find out 39 from the list of indexes\par
\par
Algorithm:\par
Step 1:  First, read the search element 39 in the array.\par
Step 2: Now, compare each element in the array and find 39.\par
Step3:  if we take the first element a[0] it is 13 . So, Element is not found.\par
Step4: Now move to the next element a[1] is 9. Element is not found.\par
Step5: Like this move to the next next element a[2]  is 21, a[3] is 15.\par
Step6: Now the next element a[4] is 39 it is matching the target. So, the target element is found.\par
\par
\par
2.Binary Search Algorithm\par
 Binary search is the most frequently used technique as it is much faster than a linear search.\par
In the binary search method, the collection is repeatedly divided into half and the key element is searched in the left or right half of the collection depending on whether the key is less than or greater than the mid element of the collection.\par
A simple Binary Search Algorithm is as follows:\par
Calculate the mid element of the collection.\par
Compare the key items with the mid element.\par
If key = middle element, then we return the mid index position for the key found.\par
Else If key > mid element, then the key lies in the right half of the collection. Thus repeat steps 1 to 3 on the lower (right) half of the collection.\par
Else key < mid element, then the key is in the upper half of the collection. Hence you need to repeat the binary search in the upper half.\par
For example, take the following sorted array of 10 elements\par
\par
Let\rquote s calculate the middle location of the array.\par
Mid = 0+9/2 = 4\par
\par
#1) Key = 21\par
First, we will compare the key value with the [mid] element and we find that the element value at mid = 21.\par
\par
Thus we find that key = [mid]. Hence the key is found at position 4 in the array.\par
#2) Key = 25\par
\par
We first compare the key value to mid. As (21 < 25), we will directly search for the key in the upper half of the array.\par
\par
Now again we will find the mid for the upper half of the array.\par
Mid = 4+9/2 = 6\par
The value at location [mid] = 25\par
\par
Now we compare the key element with the mid element. So (25 == 25), hence we have found the key at location [mid] = 6.\par
Thus we repeatedly divide the array and by comparing the key element with the mid, we decide in which half to search for the key. Exercise-4\par
1.LINEAR SEARCH ALGORITHM\par
\par
Linear search, often known as sequential search, is the most basic search technique.\par
Take the entire list and search for the particular element from the list by checking each element from the beginning\par
In linear search the element index is noted as a result.\par
If the element is not found, then it returns a NULL value.\par
Here is an example for a linear search algorithm.\par
\par
The procedures for implementing linear search are as follows:\par
Step 1: First, read the search element (Target element) in the array.\par
Step 2: In the second step compare the search element with the first element in the array.\par
Step 3: If both are matched, display "Target element is found" and terminate the Linear Search function. \par
Step 4: If both are not matched, compare the search element with the next element in the array. \par
Step 5: In this step, repeat steps 3 and 4 until the search (Target) element is compared with the last element of the array.\par
Step 6 - If the last element in the list does not match, the Linear Search Function will be terminated, and the message "Element is not found" will be displayed.\par
\par
\par
\par
FOR EXAMPLE:\par
The given list consists of 7 elements that are 6 arrays. Now, find out 39 from the list of indexes\par
\par
Algorithm:\par
Step 1:  First, read the search element 39 in the array.\par
Step 2: Now, compare each element in the array and find 39.\par
Step3:  if we take the first element a[0] it is 13 . So, Element is not found.\par
Step4: Now move to the next element a[1] is 9. Element is not found.\par
Step5: Like this move to the next next element a[2]  is 21, a[3] is 15.\par
Step6: Now the next element a[4] is 39 it is matching the target. So, the target element is found.\par
\par
\par
2.Binary Search Algorithm\par
 Binary search is the most frequently used technique as it is much faster than a linear search.\par
In the binary search method, the collection is repeatedly divided into half and the key element is searched in the left or right half of the collection depending on whether the key is less than or greater than the mid element of the collection.\par
A simple Binary Search Algorithm is as follows:\par
Calculate the mid element of the collection.\par
Compare the key items with the mid element.\par
If key = middle element, then we return the mid index position for the key found.\par
Else If key > mid element, then the key lies in the right half of the collection. Thus repeat steps 1 to 3 on the lower (right) half of the collection.\par
Else key < mid element, then the key is in the upper half of the collection. Hence you need to repeat the binary search in the upper half.\par
For example, take the following sorted array of 10 elements\par
\par
Let\rquote s calculate the middle location of the array.\par
Mid = 0+9/2 = 4\par
\par
#1) Key = 21\par
First, we will compare the key value with the [mid] element and we find that the element value at mid = 21.\par
\par
Thus we find that key = [mid]. Hence the key is found at position 4 in the array.\par
#2) Key = 25\par
\par
We first compare the key value to mid. As (21 < 25), we will directly search for the key in the upper half of the array.\par
\par
Now again we will find the mid for the upper half of the array.\par
Mid = 4+9/2 = 6\par
The value at location [mid] = 25\par
\par
Now we compare the key element with the mid element. So (25 == 25), hence we have found the key at location [mid] = 6.\par
Thus we repeatedly divide the array and by comparing the key element with the mid, we decide in which half to search for the key. \par
}
 